<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>WebXR AR - No Markers Needed</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            background: #000;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        #start-ar {
            padding: 20px 40px;
            font-size: 18px;
            background: #00ff88;
            color: black;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin: 20px;
        }
        #start-ar:hover {
            background: #00cc66;
        }
        #start-ar:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #info {
            text-align: center;
            max-width: 300px;
            line-height: 1.5;
        }
        #status {
            margin-top: 20px;
            font-size: 14px;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="info">
        <h2>ðŸš€ Modern AR Experience</h2>
        <p>No markers needed! Just point your camera at any surface and tap to place objects.</p>
        <button id="start-ar">Start AR Experience</button>
        <div id="status">Checking AR support...</div>
    </div>

    <script>
        let scene, camera, renderer, reticle, hitTestSource, localSpace;
        let arObjects = [];

        const startButton = document.getElementById('start-ar');
        const statusDiv = document.getElementById('status');
        const infoDiv = document.getElementById('info');

        // Check if WebXR is supported
        if ('xr' in navigator) {
            navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                if (supported) {
                    statusDiv.textContent = 'âœ… AR Ready!';
                    startButton.addEventListener('click', startAR);
                } else {
                    showFallback();
                }
            }).catch(() => {
                showFallback();
            });
        } else {
            showFallback();
        }

        function showFallback() {
            statusDiv.textContent = 'âš ï¸ WebXR not supported - showing demo mode';
            startButton.textContent = 'Start Demo (No AR)';
            startButton.addEventListener('click', startDemo);
        }

        async function startAR() {
            try {
                // Initialize Three.js
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.xr.enabled = true;

                document.body.appendChild(renderer.domElement);
                infoDiv.style.display = 'none';

                // Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(0, 1, 1);
                scene.add(directionalLight);

                // Create reticle (targeting circle)
                const reticleGeometry = new THREE.RingGeometry(0.15, 0.2, 32);
                const reticleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
                reticle.matrixAutoUpdate = false;
                reticle.visible = false;
                scene.add(reticle);

                // Start AR session
                const session = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test']
                });

                renderer.xr.setSession(session);

                // Set up hit testing
                const referenceSpace = await session.requestReferenceSpace('local');
                const viewerSpace = await session.requestReferenceSpace('viewer');
                hitTestSource = await session.requestHitTestSource({ space: viewerSpace });
                localSpace = referenceSpace;

                // Handle screen tap to place objects
                session.addEventListener('select', onSelect);

                renderer.setAnimationLoop(render);

            } catch (error) {
                console.error('AR failed:', error);
                statusDiv.textContent = 'âŒ AR failed - trying demo mode';
                startDemo();
            }
        }

        function startDemo() {
            // Fallback demo mode
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000011);

            document.body.appendChild(renderer.domElement);
            infoDiv.style.display = 'none';

            // Add some demo objects
            addDemoObjects();

            // Simple orbit controls simulation
            let time = 0;
            function animate() {
                time += 0.01;
                camera.position.x = Math.sin(time) * 5;
                camera.position.z = Math.cos(time) * 5;
                camera.lookAt(0, 0, 0);

                arObjects.forEach(obj => {
                    obj.rotation.y += 0.02;
                });

                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            animate();
        }

        function addDemoObjects() {
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(0, 1, 1);
            scene.add(directionalLight);

            // Add some colorful cubes
            for (let i = 0; i < 5; i++) {
                const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
                const material = new THREE.MeshLambertMaterial({
                    color: new THREE.Color().setHSL(i / 5, 1, 0.5)
                });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set((i - 2) * 1.5, 0, 0);
                scene.add(cube);
                arObjects.push(cube);
            }
        }

        function onSelect() {
            if (reticle.visible) {
                // Create a new object at the reticle position
                const geometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
                const material = new THREE.MeshLambertMaterial({
                    color: Math.random() * 0xffffff
                });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.setFromMatrixPosition(reticle.matrix);
                cube.rotation.y = Math.random() * Math.PI * 2;
                scene.add(cube);
                arObjects.push(cube);
            }
        }

        function render(timestamp, frame) {
            if (frame && hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);

                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const pose = hit.getPose(localSpace);

                    reticle.visible = true;
                    reticle.matrix.fromArray(pose.transform.matrix);
                } else {
                    reticle.visible = false;
                }
            }

            // Animate existing objects
            arObjects.forEach(obj => {
                obj.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
        });
    </script>
</body>
</html>